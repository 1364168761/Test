1	题目一：最长回文子序列
1.1	题目描述
题目要求对于一个字符串，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
回文子序列定义为：左右对称的子序列。
其中字符串只由小写字母组成。并且字符串不为空。

1.2	算法描述
1描述思路
该题可用递归求解：定义两个指针分别从前后移动，当指向的两数相等时，回文子序列长度加2，指针分别移动1位，继续递归调用；否则，比较左指针移动1位后的长度和右指针移动1位后的长度，取较大者。对于给定字符串s，有两种情况：含有奇数个字符、含有偶数个字符，分别涉及左指针等于右指针和左指针大于右指针的情况，返回值分别为1和0。

2伪代码
//输入：字符串s
//输出：s的最大回文子序列的长度
Function LPS（s）
	function func(i,j)
		if i > j: return 0
		if i == j: return 1
		if s[i] == s[j]:
			return func(i+1,j-1)+2
		return max(func(i+1,j),func(i,j-1))
return func(0,s.len-1)

1.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：s=aaaba
输出：4
2运行结果截图
 
1.4	时间复杂度分析
时间复杂度为O(n^2):在最坏情况下，每次寻找到相同元素或未找到相同元素，都需要从自身遍历到另一边。

2	题目二：最长递增子序列
2.1	题目描述
对于一个整数数组，要求出其最长递增子序列。
该数组不为空，且要求严格递增，即不包含相等的情况。

2.2	算法描述
1描述思路
该题可用动态规划解决：可以设定dp[i]是以nums[i]结尾时的最长递增子序列长度。要知道数组nums以nums[len(nums)-1]结尾的最长递增子序列长度，可以先求以nums[{0~len(nums)-2}]结尾的最长递增子序列长度。若后数比前一个数大，则说明二者可以构成递增，以前一个数结尾的长度+1，并与后者的长度对比，取较大者。而每一个元素都可以构成一个长度为1的子序列，故设dp[i]初始值均为1.
即有递推方程：dp[i] = max(dp[i],dp[j]+1) for j in range(i);dp[i]初始状态值为1；返回值:max(dp)

2伪代码
//输入：非空整数数组nums
//输出：最长递增子序列的长度
i ← 0
dp[0~nums.len-1] ← 1
while i < nums.len:
	j = 0
	while j < i:
		if nums[i] > nums[j]:
			dp[i] ← max(dp[i],dp[j]+1) 
		j ← j+1
	i ← i + 1
return max(dp)
2.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：[10,9,2,5,3,7,101,1]
输出：4
2运行结果截图	
 
2.4	时间复杂度分析
时间复杂度为O(n^2)：执行了两层循环嵌套，若以第二层循环内的代码为基本操作，则执行了1+2+…+n次数，整理得其中最大包含n^2。

3	题目三：最长公共子序列
3.1	题目描述
给定两个字符串text1和text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列返回0。
两个字符串的公共子序列是这两个字符串所共同拥有的子序列。
要求字符串不为空串。

3.2	算法描述
1描述思路
该题可用动态规划解决：可以设定dp[i][j]是两个字符串分别以text1[i]和text2[j]结尾时，最长公共子序列的长度。从后往前找出二者相等的元素，即可找到最长公共子序列。当text1[i] = text2[j]时，说明两个字符串最后一位相等，此时公共子序列长度+1。若text1[i] != text2[j]，则此时的dp[i][j]=max(dp[i-1][j],dp[i][j-1])。其中当i=0或j=0时，dp[i][j]为0，即与空串的公共子序列长度为0。
即有递推公式：dp[i][j] = dp[i-1][j-1]+1  #text1[i] == text2[j],
dp[i][j] = max(dp[i-1][j],dp[i][j-1])  #text1[i] != text2[j],
dp[i][j]初始状态值为0,返回值为dp[text1.len-1][text2.len-1]

2伪代码
//输入：非空字符串text1，非空字符串text2
//输出：两个字符串的最长公共子序列长度
n1,n2 ← len(text1),len(text2)
dp[i][j] ← 0 #size=(n1+1)*(n2+1),加1是为了避免边界处理，如i或j为0
i,j ← 1
while i < n1+1:
	while j < n2+1:
		if text1[i-1] == text2[j-1]:
			dp[i][j] = dp[i-1][j-1]+1
		else:
			dp[i][j] = max(dp[i-1][j],dp[i][j-1])
return dp[n1][n2]

3.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：text1=“abcde”，text2=“ace”
输出：3
2运行结果截图
 
3.4	时间复杂度分析
时间复杂度为O(n^2):使用了两层循环嵌套
4	题目四：编辑距离
4.1	题目描述
对于两个单词word1和word2，请返回将word1转换成word2所使用的最少操作数。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字符

4.2	算法描述
1描述思路
该题可用动态规划解决：可以设dp[i][j]为word1到元素[i]时，转换word到元素[j]的最少操作数。当word1[i]==word2[j]时，说明二者此时不需要任何操作。当word1[i]!=word2[j]时，可以进行三种操作，操作后操作数要加1。若i=0或j=0，则操作数等于非空字符串的字符数。
即有递推方程：dp[i][j] = dp[i-1][j-1] #word1[i] == word2[j],
dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1,
其中dp[i-1][j-1]代表替换，dp[i-1][j]代表删除,dp[i][j-1]代表添加。理解为已经将word1的前x字符替换为word2的前y字符，进行操作可将其变为将word1的前i字符替换为word2的前j字符。
由于边界处理，i=0或j=0时单独处理。

2伪代码
//输入：由小写字母组成，可以为空的字符串word1和word2
//输出：将word1通过题目所给操作转换成word2所需操作数
n1,n2 ← len(word1),len(word2)
#word1为行
dp = [[0] * (n2+1) for m in range(n1+1)]
i,j ←1
#加1避免边界处理
while j < n2+1:
	dp[0][j] ←dp[0][j-1]+1
	j ← j+1
while i < n1+1:
	dp[i][0] ←dp[i-1][0]+1
	i ← i+1
i,j ←1
while i < n1+1:
	while j < n2+1:
		if  word1[i-1] == word2[j-1]:
			dp[i][j] ←dp[i-1][j-1]
		else:
			dp[i][j] ← min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1
return dp[n1][n2]
4.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：word1,word2=”horse”,”ros”
输出：3
2运行结果截图
 
4.4	时间复杂度分析
时间复杂度为O(n^2)：存在两层循环嵌套，最大阶为n^2

5	题目五：最长等差子序列
5.1	题目描述
返回一个整数数组nums中最长等差子序列的长度。
要求nums最少包含两个元素。
nums[i]范围：[0,500]
5.2	算法描述
1描述思路
该题可用动态规划解决：可以设dp[i][d]为数组的nums[i]与前面的数差值为d时，最长等差子序列的长度。要求nums的最长等差子序列的长度，可以划分为先求去掉最后一个元素的数组的序列长度。故先计算只有一个元素时，初始值为1，与自己构成序列。用一个变量ans每次记录d[i][d]与已记录值的较大者。
由于题目的范围限制，差值d可能为负，故每次求差值加上500，避免处理负数，其差值d范围：[0,1000]
即有递推公式：dp[i][d] = max(dp[i][d],dp[{0~i-1}][d] + 1)
ans = max(ans,dp[i][d])
其中+ 1表示在原有差值的序列基础上加1个满足条件的元素
2伪代码
//输入：至少包含两个元素的整数数组nums
//输出：nums的最长等差子序列的长度
n ← len(nums)
#[1]*1001:表示差值；行为nums下标，列为差值；d[0,1000]
dp  ← [[1] * 1001 for _ in range(n)]
ans ← 0
i ← 1
while i < n:
	j ← 0
while j < i:
#加500：避免处理负数
d ← nums[i] - nums[j] + 500
dp[i][d] ← max(dp[i][d], dp[j][d] + 1)
#记录max(已记录最长，新长度)
ans ← max(ans, dp[i][d])
return ans


5.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：nums = [9,4,7,2,10]
输出：3
2运行结果截图
 
5.4	时间复杂度分析
时间复杂度为O(n^2):存在两层循环嵌套
6	题目六：Kruskal
6.1	题目描述
使用并查集、kruskal算法创建一个图的最小生成树，要求用图形界面展示最小生成树。
并查集：核心思想是维护一个由若干个不相交的集合所组成的数据结构，并能高效地进行合并集合和查找元素所属集合的操作。
最小生成树：给定一个图G=(V,E),我们用(u, v)表示一条边，w(u, v)表示边(u, v)的权重，如果存在图T为G的子集，且T里面没有环，如果使得w(T)最小，则T为G的最小生成树。
6.2	算法描述
1描述思路
按照kruskal算法的思路，将边按照权重从小到大排列枚举第一个边，加入MST里，判断是否成环如果成环则跳过，否则确定这条边为MST里的继续枚举下一条边，直到所有的边都枚举完。
其中判断是否成环可以使用并查集实现：存储所有结点，并初始化其父节点为自身。
当两个结点的根结点在路径压缩的情况下相等时，则这两点组成的边会导致构成回路。

2伪代码
//输入：图形G
//输出：图形G的最小生成树
f[] ← [0~G.nodes.len , 0~G.nodes.len] #初始化结点的父节点为自身
edges ← G.edges #包含[点1，点2，权重]
edges.sort  #按权重从低到高
function find(x):
	if x==f[x]: #找到根结点
		return x
else:
	f[x] = find(f[x]) #路径压缩，即将x的根结点f[x]设为直到满足x==f[x]的结点
	return f[x]
count ← 0 #计算边的数量
while edges.hasNext():
	if count >= f.len – 1
	 	break
	u = find(edge[0])
	v = find(edge[1])
	if u==v:
		continue#根结点相同，此时在两边均与根结点相连的情况下，连接任意第三边会构成环路，故跳过
	G1.addEdge(u,v,edge[2])
	count ← count + 1

G1.show #展示


6.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：G=[(0,1,4),(1,2,8),(2,5,2),(1,3,7),(2,4,9),(3,4,10)] //（点1，点2，权重）
输出：对应的最小生成树，见下方运行结果截图
2运行结果截图
 

6.4	时间复杂度分析
时间复杂度O(n)：其中寻找根结点的方法经过路径压缩，时间复杂度接近O(1)，在构造最小生成树中用了单层循环遍历边的集合，最多遍历n-1，其中n是结点的个数，故时间复杂度是O(n)
7	题目七：跨省验证
7.1	题目描述
从湖北出发最多只需要跨越两个省就可以到达中国任何一个省。请设计实验对此进行验证。
7.2	算法描述
1描述思路
该问题可用Dijkstra算法解决：本问可以看作：对于给定的无向图，每条边权值为1，验证从给定点出发到任一点的距离小于等于3。
故按照Dijkstra算法的思路，初始化时将湖北放到已求出最短距离的集合，将其它省放到未求出最短距离的集合。每次操作都从后一个集合中取出与前一个集合距离最短的省，放入前一个集合中，然后更新后一个集合的数据。

2伪代码
dist ← {{nodes}:∞} #源点到其他的初始化为∞
dist[start] ← 0 #源点到自身距离为0
heap[] ← [0,start] #离源点距离，当前结点
while heap:
	distance,current_node ← heapq.heapop(heap)
	# 当前节点已经求出最短路径
	if distance > dist[current_node]:
    		continue
	遍历当前节点的相邻节点,更新最短路径距离
最后再比较是否有路径长度大于3，返回验证的布尔值
7.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：包含了各省邻接关系的字典graph,详见源代码，以及开始结点
输出：True
2运行结果截图
 

7.4	时间复杂度分析
时间复杂度是O(nlogn)：Dijkstra算法的时间复杂度是O(V+ElogV)，其中V为节点数，E为边数。
8	题目八：三分查找、二分查找
8.1	题目描述
设计实验比较三分查找算法和二份查找算法平均情形时间复杂度。
8.2	算法描述
1描述思路
对于有序集合，二分查找算法的思路是比对目标数和当前序列中位数，若相等则返回下标，若不等则根据大小结果在中位数的左集合或右集合查找；三分查找算法的思路是对比目标数与1/3处和2/3处的数是否相等，若相等则返回下标，若不等则比较两数与目标数的大小，判断其在0~1/3区或1/3~2/3区或2/3~1区。
现在可以使用一个大型数组输入对两种算法进行计时，多次实验，最后取平均值，便可比较两种算法平均情形时间复杂度。
根据定理可知二分查找和三分查找时间复杂度分别为：O(log2n),O(2log3n)，可画出下图，其中f1=( log2n)在x=1之后小于f2=(2log3n)，即要求三分查找最坏时间复杂度大于二分查找：
 
2伪代码
//输入：数组arr，左下标start,右下标end,目标数x
//输出：两种算法的执行时间
i ← 1
while i < 4
print(第i次)
T1 ← time.now
二分查找
T2 ← time.now
print(运行时间是：T1-T2)
T1 ← time.now
三分查找
T2 ← time.now
print(运行时间是：T1-T2)
i ← i + 1

8.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：随机生成的大型数组arr，设定其为随机生成的长10000，元素范围[1,20000)的数组；左下标start=0，右下标end=len(arr)-1，目标数x=arr[44]
输出：两种算法多次的执行时间，见下面运行结果截图
2运行结果截图
 

8.4	时间复杂度分析
根据定理可知二分查找和三分查找时间复杂度分别为：O(log2n),O(2log3n)
9	题目九：最接近点对
9.1	题目描述
随机产生平面若干点，利用蛮力算法和分治算法找到平面的最接近点对，并考查随 n 变大时，两者的效率差异、实验效率和理论效率的一致性。平面点集能直观的进行观察。
9.2	算法描述
1描述思路
蛮力算法：穷举，将所有点对的距离求出来取最小值对应的点对
分治算法：分治的思路是将大的问题分为小问题，这里可以将求大集合最小点对按x的中位数分割为求左集合与右集合，递归分割，直到集合点数小于等于3（避免边界处理），进行蛮力求解。然后检查跨集合的点对是否有更小的距离，将集合与最近的集合合并（要满足点到合并集合的x的中位线的距离小于已有最小点对距离），再求集合中每个点的差的绝对值，若大于已有最小点对距离则舍弃，最后蛮力求解，并于已有最小点对距离比较，保留较小者。
效率比较：使用计时程序比较，用散点图展示

2伪代码
蛮力：
使用两层嵌套循环，遍历所有点对并计算距离，取距离最小的点对

分治：
#①按x排序
#②按x中位数分两部分
#③重复①②，直到点数<=3              //防止处理点数为1的情况
#④计算每个小集合的最近邻接点对，及其距离
#⑤合并最近的两个小集合，按x中位数划分，集合的最近邻接点取较小值    //检查跨越边界的点对
#⑥保留到中位线距离小于点对距离的点  //筛选
#⑦若中位线左边和右边均不为空，计算跨界的最近邻接点对，并与已有最近邻接点对比较取较小值
#⑧重复⑤⑥⑦，直到集合只有一个
#⑨返回当前集合的最近邻接点对
效率分析：
使用语言内置接口对程序进行计时即可，最后用散点图展示

9.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：随机生成的点的个数从10到500的点集合arr
输出：两种算法随n变化的执行时间的散点图，以及求解的最小邻接点对
2运行结果截图
 
下图为部分解：
 

9.4	时间复杂度分析
蛮力算法时间复杂度：O(n^2);分治算法时间复杂度O(n^2logn):因为检查跨界点对时使用了两层嵌套循环
10	题目十：随机有向图
10.1	题目描述
随机产生 n 个顶点的有向图，并预设两点之间出现有向边的概率，然后探索前两个参数和图中出现环的关系。需要有图形展示。
10.2	算法描述
1描述思路
设参数：n:顶点个数，edge_probability:两点间出现有向边的概率，可以设计以下两种控制变量实验
探索n与图有环的关系：保持edge_probability不变，将n逐渐增加，探索图中是否有环，每个n测试3次。
探索edge_probability与图有环的关系：保持n不变，将edge_probability逐渐增加到1，探索图中是否有环，每个edge_probability测试3次。
判断图是否有环可用python中的networkx包实现。
绘制柱状图(变量-次数): 可用python中的 matplotlib.pyplot包实现。

2伪代码
function 生成随机有向图(n, edge_probability):
	#使用random进行随机	
return G
function 是否有环(G):
	#any(networkx.simple_cycles(G))
function 绘制柱状图(x轴标记，有环次数:list，无环次数:list):
	#plt实现
#探索实验：edge_probability不变，n逐渐增加，每个n测试3次
n从i到j，每个n循环测试3次，记录每次是否有环
#探索实验：n不变，将edge_probability逐渐增加到1，每个edge_probability测试3次，记录每次是否有环
10.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：测试数据1：n = {5~20},pro=0.3 。测试数据2：n = 5,pro={0.3~1}
输出：柱状图1（n-次数），柱状图2(pro-次数)，见下图
2运行结果截图
 
Figure 1 n-次数
 
Figure 2 pro-次数

10.4	时间复杂度分析
时间复杂度为O(n^2):其中控制变量时使用了两层嵌套循环
11	题目十一：括号生成
11.1	题目描述
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。
11.2	算法描述
1描述思路
一对有效括号：要求左括号在右括号的左边，不考虑中间隔了多少元素
最左边必须是左括号。
本文可以用回溯法解决：当左括号数left<n时，可以生成左括号，并递归调用生成方法；接着当右括号数right < left时，可以生产右括号，并递归调用生成方法。当临时变量temp(string)中存储的元素等于2n时即可返回。前两个约束条件可以保证：①最左边是左括号②不会产生没有左括号对应的右括号。
2伪代码
//输入：括号对数n
//输出：包含n对括号的所有有效组合
answer = [] #所有有效组合
function  backtrack():
	if temp.len == 2*n:
		answer中加入temp
		return
	if left < n:
		temp中加入左括号
		backtrack()
		temp.pop
	if right < left:
		teno中加入右括号
		backtrack()
		temp.pop
backtrack([],0,0)
return answer
11.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：n = 3
输出：['((()))', '(()())', '(())()', '()(())', '()()()']
2运行结果截图
 

11.4	时间复杂度分析
时间复杂度：O(2^n):本题要求判断每个位置上是’(’ 还是‘)’，有两种可能，故2*2*2*…*2 = 2^n 
12	题目十二：电话号码的字母组合
12.1	题目描述
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
 
提示： 
0 <= digits.length <= 4 
digits[i] 是范围 [‘2’, ‘9’] 的一个数字。
12.2	算法描述
1描述思路
回溯法可解：遍历digits的所有数字，每次遍历一个数字时对其所有映射字母进行遍历，每次遍历一个字母时将其记录，添加在temp最后。递归寻找下一个数字的字母。每次遍历到底时添加该组合，返回上一个递归并删除最后一个元素。如此可遍历给定列表的所有组合方式。
2伪代码
//输入：空列表ans，数字字符串digits，digits的当前下标start，记录当前组合的字符串temp，映射信息字典info
//输出：包含所有组合的列表ans
递归结束条件：start == digits.len
letters ← info[digits[start]] #记录当前数字的映射
遍历映射，对记录当前字母，递归调用方法，其中start加1，最后删除当前记录的最后一位元素
12.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：ans = [],digits=’27’,start=0,temp=’’,
info = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz’}
输出：['ap', 'aq', 'ar', 'as', 'bp', 'bq', 'br', 'bs', 'cp', 'cq', 'cr', 'cs']
2运行结果截图
 
12.4	时间复杂度分析
时间复杂度是O(m^n):本题算法时间复杂度取决于digits的长度n，以及映射字母串的长度，设字母串平均长度m,对于每个数字的字母，有m种可能。
13	题目十三：迷宫寻路
13.1	题目描述
1. 产生图形用户界面，设计一个迷宫生成算法，使得产生的每个迷宫都是有解的 
2. 能绘制出从起点到终点的路径。路径通过 BFS 和 DFS 遍历得到。 
3. 实现 A* 算法，将 A* 算法的运行和 BFS 的运行进行比较（产生不同的迷宫，分别运行 A* 和 BFS 算法，多次比较他们的快慢） 
参考： 
6i. https://www.bilibili.com/video/BV1eX4y1v7rS/ 
ii. https://www.youtube.com/watch?v=-L-WgKMFuhE
13.2	算法描述
1描述思路
2伪代码
13.3	程序运行及其结果
1给出程序接受的输入和对应的输出
输入：
输出：
2运行结果截图

13.4	时间复杂度分析

14	小结
写心得和反馈
